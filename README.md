# Intersection Programming Interface (IPI)

The IPI project defines a communications fabric that links intelligent
intersections with connected vehicles (CVs), connected and autonomous vehicles
(CAVs), pedestrians, peer intersections, and cloud services. This repository
captures both the specification and reference implementations needed to explore
the architecture end-to-end.

## Repository Layout

| Path | Description |
| --- | --- |
| `api/README.md` | Human-readable API design covering transport planes, topic/end-point contracts, payload schemas, rate limits, and operational guidance. |
| `cpp/` | C++17 reference library implementing the data models, UPER encoding helpers, optional ROS 2/Mocar adapters, vehicle–vehicle mesh helpers, and in-memory receiver/sender APIs. |
| `third_party/mocar/` | Vendor SDK artifacts and samples for Mocar RSU/OBU devices (used by the optional hardware demos). |
| `v2x_msg/` | ROS 2 message definitions for V2X (required when building the ROS integration). |

## C++ Reference Implementation

The `cpp/` tree exposes several reusable components:

- `ipi::core` – strongly-typed representations of the IPI request/response data
  structures, including the BSM `IPI-ServiceRequest` extension and the
  `IPI-CooperativeService` regional payload used for guided planning/
  perception/control.
- `ipi::v2x` – simplified SAE J2735 helpers (BSM, MAP, SPaT, SRM, SSM) plus the
  `UperCodec` for ASN.1 UPER packing/unpacking and optional ROS 2 bridge
  adapters (`Ros2Bridge`) to translate between ROS messages and the lightweight
  structs.
- `ipi::api` – interfaces (`ReceiverApi`, `SenderApi`) that mirror the HTTP and
  MQTT semantics in the spec. Factory helpers produce thread-safe in-memory
  implementations so you can prototype against the contract without deploying a
  backend.
 - `ipi::mesh` – a vehicle–vehicle mesh manager used in power‑outage scenarios where SPaT/MAP/5G are unavailable. It tracks nearby vehicles from BSMs and exchanges `IPI-CooperativeService` guidance frames directly over V2V links.

### Building

```bash
cmake -S cpp -B cpp/build
cmake --build cpp/build
```

This produces `libipi.a` and the example executables described below. Optional
integrations can be toggled via CMake flags.

### Example Programs

- `example_build_service_request`
  Demonstrates constructing and serialising an `IPI-ServiceRequest` and an
  `IPI-CooperativeService` payload. Use it as boilerplate when crafting service
  requests or cooperative guidance data.

- `example_v2x_roundtrip`
  Exercises the J2735 helpers and the `UperCodec` by encoding/decoding synthetic
  BSM, MAP, SPaT, SRM, and SSM frames. Replace the synthetic values with live
  sensor input to simulate RSU broadcasts.

- `example_mocar_ipi` *(requires `IPI_ENABLE_MOCAR_EXAMPLES=ON`)*
  Wraps the Mocar SDK so RSU/OBU devices can broadcast the core message types.
  Ideal for hardware bring-up when no full intersection backend exists yet.

- `example_ros2_bsm_broadcaster` *(requires both `IPI_ENABLE_ROS2_BRIDGE=ON`
  and `IPI_ENABLE_MOCAR_EXAMPLES=ON` inside a ROS 2 workspace)* Subscribes to
  `v2x_msg::msg::BSM` (e.g., generated by perception/camera pipelines), converts
  it to the lightweight model, validates it through the UPER codec, and
  broadcasts the result via the Mocar SDK.
 - `example_mesh_demo`
  Uses `ipi::mesh::MeshManager` with a simple logging transport to demonstrate the vehicle–vehicle local mesh mode: it ingests synthetic BSMs, simulates loss of infrastructure heartbeats, and shows cooperative guidance frames being broadcast when mesh mode activates.

### Optional Integrations

- `-DIPI_ENABLE_ROS2_BRIDGE=ON` – builds the ROS 2 bridge helpers inside a ROS
  workspace where `v2x_msg` is available.
- `-DIPI_ENABLE_MOCAR_EXAMPLES=ON` – enables demos that call the Mocar SDK (RSU
  hardware); requires `third_party/mocar/libs/libmocarv2x.so`.
- Enabling both flags adds the ROS→Mocar BSM broadcaster sample described above.

## Demo: Edge→Device SPaT over TCP

This demo uses the host-built TCP sender and the J2735-2020 bridge on the
Mocar device.

### Build the pieces

1) Edge sender (host/Orin):
```bash
cmake -S cpp -B cpp/build
cmake --build cpp/build --target example_spat_tcp_sender
```

2) Device bridge (J2735-2020 SDK, cross-compile on host):
```bash
cd third_party/mocar/J2735-2020/samples/ipi_spat_bridge
make clean && make   # produces ipi_spat_bridge (aarch64)
```

### Run the demo

On the Mocar broadcasting device (with `libmocarcv2x.so` and `libzlog.so`
available at `../lib` relative to the binary):
```bash
./ipi_spat_bridge            # listens on TCP port 35555 by default
```

On the edge device (replace IP with the broadcaster’s address):
```bash
./cpp/build/example_spat_tcp_sender 192.168.253.40 35555
```

Override phases/states/timing if needed:
```bash
./cpp/build/example_spat_tcp_sender 192.168.253.40 35555 1 3 5000 2 1 5000
# state map: 0=dark,1=stopAndRemain,2=stopThenProceed,3=proceed,4=flashing
```

Enable debug hex dumps in the sender with `IPI_DEBUG=1` when troubleshooting.

## Working with the Design

Start with `api/README.md` to understand the overall architecture,
communication planes, and payload contracts. The C++ APIs mirror the same
nomenclature so you can stub or back the interfaces with your infrastructure of
choice. The mesh behaviour and power‑outage scenario are documented in
`cpp/LOGIC.md` and implemented in `ipi::mesh::MeshManager`. For hardware-in-the-loop
experiments, reuse the optional Mocar helpers; for ROS-based perception systems,
publish detected vehicles as BSM messages and forward them using the provided
broacaster and mesh samples.

Contributions are welcome—open issues or PRs when expanding the spec, porting
encoders, or wiring production backends to the `ReceiverApi`/`SenderApi`
interfaces.
